/**
 * TerrainDataProvider - Provides terrain data to collision and game systems
 * 
 * This is a thin wrapper that routes queries to the ChunkBlockCache
 * which contains data generated by the web worker.
 * 
 * SMOOTH TERRAIN ARCHITECTURE:
 * - getGroundHeight() automatically routes to heightmap or voxel collision
 * - getInterpolatedHeight() provides smooth heights for entity movement
 * - isSolid() and getBlockType() use voxel data for 3D queries
 * 
 * The worker is the SINGLE SOURCE OF TRUTH - this class does NOT
 * generate any terrain data itself.
 */

export class TerrainDataProvider {
    constructor(workerManager) {
        this.workerManager = workerManager;
    }
    
    /**
     * Get block type at world coordinates
     * @param {number} x - World X coordinate
     * @param {number} y - World Y coordinate  
     * @param {number} z - World Z coordinate
     * @returns {string|null} Block type name, or null for air/unloaded
     */
    getBlockType(x, y, z) {
        return this.workerManager.getBlockType(x, y, z);
    }
    
    /**
     * Check if a block is solid (for collision)
     * @param {number} x - World X coordinate
     * @param {number} y - World Y coordinate
     * @param {number} z - World Z coordinate
     * @returns {boolean} True if block is solid
     */
    isSolid(x, y, z) {
        const blockType = this.getBlockType(x, y, z);
        if (blockType === null) return false;
        if (blockType === 'water' || blockType === 'water_full') return false;
        return true;
    }
    
    /**
     * Get ground height at world coordinates
     * Automatically routes to smooth (heightmap) or voxel collision based on mask
     * 
     * For smooth terrain: returns interpolated float height
     * For voxel terrain: returns integer block height + 1
     * 
     * @param {number} x - World X coordinate (can be fractional)
     * @param {number} z - World Z coordinate (can be fractional)
     * @returns {number} Ground height
     */
    getGroundHeight(x, z) {
        return this.workerManager.getGroundHeight(x, z);
    }
    
    /**
     * Get terrain height at integer position
     * Note: This scans the block column, which is slightly slower than
     * a dedicated heightmap but ensures consistency with block data.
     * 
     * @param {number} x - World X coordinate
     * @param {number} z - World Z coordinate
     * @returns {number} Height of topmost solid block, or 0 if no data
     */
    getHeight(x, z) {
        const MAX_HEIGHT = 64;
        
        // Scan from top down to find first solid block
        for (let y = MAX_HEIGHT - 1; y >= 0; y--) {
            const blockType = this.getBlockType(x, y, z);
            if (blockType !== null && 
                blockType !== 'water' && 
                blockType !== 'water_full') {
                return y;
            }
        }
        
        return 0;
    }
    
    /**
     * Get interpolated height at any world position
     * Uses bilinear interpolation from the heightmap for smooth terrain
     * Falls back to voxel height scan for voxelized cells
     * 
     * @param {number} x - World X coordinate (can be fractional)
     * @param {number} z - World Z coordinate (can be fractional)
     * @returns {number} Interpolated height
     */
    getInterpolatedHeight(x, z) {
        // Use the new ground height method which handles routing
        return this.getGroundHeight(x, z);
    }
    
    /**
     * Check if a position uses voxel collision (vs smooth heightmap)
     * @param {number} x - World X coordinate
     * @param {number} z - World Z coordinate
     * @returns {boolean} True if voxel collision, false if heightmap
     */
    usesVoxelCollision(x, z) {
        return this.workerManager.usesVoxelCollision(x, z);
    }
    
    /**
     * Check if block data is available at a position
     * Useful for checking if terrain is loaded before spawning entities
     */
    isLoaded(x, z) {
        const CHUNK_SIZE = 16;
        const chunkX = Math.floor(x / CHUNK_SIZE);
        const chunkZ = Math.floor(z / CHUNK_SIZE);
        return this.workerManager.hasBlockData(chunkX, chunkZ);
    }
}