/**
 * ChunkBlockCache - Stores voxel block data received from the web worker
 * 
 * This is the main thread's read-only view of terrain data.
 * All block data is generated by the worker and transferred here.
 * Collision and game logic query this cache instead of regenerating terrain.
 * 
 * Data format per chunk:
 * - blockData: Uint8Array[CHUNK_SIZE * MAX_HEIGHT * CHUNK_SIZE]
 * - Indexed as: y * (CHUNK_SIZE * CHUNK_SIZE) + z * CHUNK_SIZE + x
 * - Block type encoded as uint8 (0 = air, 1+ = block types)
 */

export const CHUNK_SIZE = 16;
export const MAX_HEIGHT = 64;

// Block type encoding (uint8)
// 0 = air (null), 1+ = solid block types
export const BLOCK_TYPE_IDS = {
    air: 0,
    grass: 1,
    dirt: 2,
    stone: 3,
    snow: 4,
    sand: 5,
    water: 6,
    water_full: 7,
    ice: 8,
    mayan_stone: 9
};

// Reverse lookup: ID -> type name
export const BLOCK_TYPE_NAMES = Object.fromEntries(
    Object.entries(BLOCK_TYPE_IDS).map(([name, id]) => [id, name])
);

/**
 * Get block type ID from name
 */
export function getBlockTypeId(typeName) {
    return BLOCK_TYPE_IDS[typeName] ?? 0;
}

/**
 * Get block type name from ID
 */
export function getBlockTypeName(typeId) {
    return BLOCK_TYPE_NAMES[typeId] ?? null;
}

/**
 * Calculate array index for a local block position
 */
export function getBlockIndex(localX, y, localZ) {
    return y * (CHUNK_SIZE * CHUNK_SIZE) + localZ * CHUNK_SIZE + localX;
}

/**
 * ChunkBlockData - Block data for a single chunk
 */
export class ChunkBlockData {
    constructor(chunkX, chunkZ, blockData) {
        this.chunkX = chunkX;
        this.chunkZ = chunkZ;
        this.worldMinX = chunkX * CHUNK_SIZE;
        this.worldMinZ = chunkZ * CHUNK_SIZE;
        
        // Uint8Array transferred from worker
        this.blockData = blockData;
    }
    
    /**
     * Get block type at local coordinates
     * @param {number} localX - 0 to CHUNK_SIZE-1
     * @param {number} y - 0 to MAX_HEIGHT-1
     * @param {number} localZ - 0 to CHUNK_SIZE-1
     * @returns {string|null} Block type name or null for air
     */
    getBlockTypeLocal(localX, y, localZ) {
        if (localX < 0 || localX >= CHUNK_SIZE ||
            localZ < 0 || localZ >= CHUNK_SIZE ||
            y < 0 || y >= MAX_HEIGHT) {
            return null;
        }
        
        const index = getBlockIndex(localX, y, localZ);
        const typeId = this.blockData[index];
        return getBlockTypeName(typeId);
    }
    
    /**
     * Get block type at world coordinates
     * @param {number} worldX - World X coordinate
     * @param {number} y - Y coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {string|null} Block type name or null for air
     */
    getBlockType(worldX, y, worldZ) {
        const localX = worldX - this.worldMinX;
        const localZ = worldZ - this.worldMinZ;
        return this.getBlockTypeLocal(localX, y, localZ);
    }
}

/**
 * ChunkBlockCache - Central cache for all loaded chunk block data
 */
export class ChunkBlockCache {
    constructor() {
        // Map of "chunkX,chunkZ" -> ChunkBlockData
        this.chunks = new Map();
    }
    
    /**
     * Store block data for a chunk (received from worker)
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkZ - Chunk Z coordinate
     * @param {Uint8Array} blockData - Block data array from worker
     */
    setChunkData(chunkX, chunkZ, blockData) {
        const key = `${chunkX},${chunkZ}`;
        this.chunks.set(key, new ChunkBlockData(chunkX, chunkZ, blockData));
    }
    
    /**
     * Remove block data for a chunk (when unloaded)
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkZ - Chunk Z coordinate
     */
    removeChunk(chunkX, chunkZ) {
        const key = `${chunkX},${chunkZ}`;
        this.chunks.delete(key);
    }
    
    /**
     * Get block type at world coordinates
     * @param {number} x - World X coordinate
     * @param {number} y - Y coordinate
     * @param {number} z - World Z coordinate
     * @returns {string|null} Block type name, or null for air/unloaded
     */
    getBlockType(x, y, z) {
        const chunkX = Math.floor(x / CHUNK_SIZE);
        const chunkZ = Math.floor(z / CHUNK_SIZE);
        const key = `${chunkX},${chunkZ}`;
        
        const chunkData = this.chunks.get(key);
        if (!chunkData) {
            // Chunk not loaded - treat as air
            return null;
        }
        
        return chunkData.getBlockType(x, y, z);
    }
    
    /**
     * Check if a chunk's block data is loaded
     */
    hasChunk(chunkX, chunkZ) {
        return this.chunks.has(`${chunkX},${chunkZ}`);
    }
    
    /**
     * Get number of loaded chunks
     */
    get size() {
        return this.chunks.size;
    }
    
    /**
     * Clear all cached data
     */
    clear() {
        this.chunks.clear();
    }
}