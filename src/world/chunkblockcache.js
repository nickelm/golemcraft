/**
 * ChunkBlockCache - Stores terrain data received from the web worker
 * 
 * This is the main thread's read-only view of terrain data.
 * All data is generated by the worker and transferred here.
 * 
 * SMOOTH TERRAIN ARCHITECTURE:
 * - heightmap: Float32Array of continuous heights for smooth collision
 * - voxelMask: Uint8Array indicating which cells use voxel collision
 * - blockData: Uint8Array of block types for voxel collision
 * 
 * Collision routing:
 * - If voxelMask[cell] == 0: use heightmap interpolation
 * - If voxelMask[cell] == 1: use blockData voxel queries
 */

export const CHUNK_SIZE = 16;
export const MAX_HEIGHT = 64;
const HEIGHTMAP_SIZE = CHUNK_SIZE + 1;

// Block type encoding (uint8)
// 0 = air (null), 1+ = solid block types
export const BLOCK_TYPE_IDS = {
    air: 0,
    grass: 1,
    dirt: 2,
    stone: 3,
    snow: 4,
    sand: 5,
    water: 6,
    water_full: 7,
    ice: 8,
    mayan_stone: 9,
    cave_stone: 10,
    cave_floor: 11,
    bedrock: 12,
    tnt: 13
};

// Reverse lookup: ID -> type name
export const BLOCK_TYPE_NAMES = Object.fromEntries(
    Object.entries(BLOCK_TYPE_IDS).map(([name, id]) => [id, name])
);

// Biome ID encoding (matches chunkdatagenerator.js)
export const BIOME_IDS = {
    ocean: 0,
    plains: 1,
    desert: 2,
    jungle: 3,
    snow: 4,
    mountains: 5
};

// Reverse lookup: ID -> biome name
export const BIOME_NAMES = {
    0: 'ocean',
    1: 'plains',
    2: 'desert',
    3: 'jungle',
    4: 'snow',
    5: 'mountains'
};

/**
 * Get block type ID from name
 */
export function getBlockTypeId(typeName) {
    return BLOCK_TYPE_IDS[typeName] ?? 0;
}

/**
 * Get block type name from ID
 * Returns null for air (ID 0) to match expected collision behavior
 */
export function getBlockTypeName(typeId) {
    if (typeId === 0) return null;  // Air is null, not 'air' string
    return BLOCK_TYPE_NAMES[typeId] ?? null;
}

/**
 * Calculate array index for a local block position
 */
export function getBlockIndex(localX, y, localZ) {
    return y * (CHUNK_SIZE * CHUNK_SIZE) + localZ * CHUNK_SIZE + localX;
}

/**
 * Calculate heightmap index for local coordinates
 */
function getHeightmapIndex(localX, localZ) {
    return localZ * HEIGHTMAP_SIZE + localX;
}

/**
 * ChunkBlockData - Complete terrain data for a single chunk
 */
export class ChunkBlockData {
    constructor(chunkX, chunkZ, data) {
        this.chunkX = chunkX;
        this.chunkZ = chunkZ;
        this.worldMinX = chunkX * CHUNK_SIZE;
        this.worldMinZ = chunkZ * CHUNK_SIZE;

        // Smooth terrain data
        this.heightmap = data.heightmap;       // Float32Array - continuous heights
        this.voxelMask = data.voxelMask;       // Uint8Array - 0=smooth, 1=voxel
        this.surfaceTypes = data.surfaceTypes; // Uint8Array - surface block types

        // Biome data
        this.biomeData = data.biomeData;       // Uint8Array - biome IDs per cell

        // Voxel data
        this.blockData = data.blockData;       // Uint8Array - 3D block types
    }
    
    /**
     * Check if a cell uses voxel collision (vs heightmap)
     * @param {number} localX - 0 to CHUNK_SIZE-1
     * @param {number} localZ - 0 to CHUNK_SIZE-1
     * @returns {boolean} True if cell uses voxel collision
     */
    usesVoxels(localX, localZ) {
        if (localX < 0 || localX >= CHUNK_SIZE || localZ < 0 || localZ >= CHUNK_SIZE) {
            return false;
        }
        const index = localZ * CHUNK_SIZE + localX;
        return this.voxelMask[index] === 1;
    }
    
    /**
     * Get continuous height at local coordinates using bilinear interpolation
     * Only valid for smooth terrain cells (voxelMask == 0)
     * 
     * @param {number} localX - 0 to CHUNK_SIZE (can be fractional)
     * @param {number} localZ - 0 to CHUNK_SIZE (can be fractional)
     * @returns {number} Interpolated height
     */
    getInterpolatedHeight(localX, localZ) {
        // Clamp to valid range
        const x = Math.max(0, Math.min(CHUNK_SIZE, localX));
        const z = Math.max(0, Math.min(CHUNK_SIZE, localZ));
        
        // Get integer and fractional parts
        const x0 = Math.floor(x);
        const z0 = Math.floor(z);
        const x1 = Math.min(x0 + 1, CHUNK_SIZE);
        const z1 = Math.min(z0 + 1, CHUNK_SIZE);
        const fx = x - x0;
        const fz = z - z0;
        
        // Sample heights at four corners
        const h00 = this.heightmap[getHeightmapIndex(x0, z0)];
        const h10 = this.heightmap[getHeightmapIndex(x1, z0)];
        const h01 = this.heightmap[getHeightmapIndex(x0, z1)];
        const h11 = this.heightmap[getHeightmapIndex(x1, z1)];
        
        // Bilinear interpolation
        const h0 = h00 * (1 - fx) + h10 * fx;
        const h1 = h01 * (1 - fx) + h11 * fx;
        return h0 * (1 - fz) + h1 * fz;
    }
    
    /**
     * Get block type at local coordinates (for voxel collision)
     * @param {number} localX - 0 to CHUNK_SIZE-1
     * @param {number} y - 0 to MAX_HEIGHT-1
     * @param {number} localZ - 0 to CHUNK_SIZE-1
     * @returns {string|null} Block type name or null for air
     */
    getBlockTypeLocal(localX, y, localZ) {
        if (localX < 0 || localX >= CHUNK_SIZE ||
            localZ < 0 || localZ >= CHUNK_SIZE ||
            y < 0 || y >= MAX_HEIGHT) {
            return null;
        }
        
        const index = getBlockIndex(localX, y, localZ);
        const typeId = this.blockData[index];
        return getBlockTypeName(typeId);
    }
    
    /**
     * Get block type at world coordinates
     * @param {number} worldX - World X coordinate
     * @param {number} y - Y coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {string|null} Block type name or null for air
     */
    getBlockType(worldX, y, worldZ) {
        const localX = worldX - this.worldMinX;
        const localZ = worldZ - this.worldMinZ;
        return this.getBlockTypeLocal(localX, y, localZ);
    }
    
    /**
     * Get ground height at world coordinates using appropriate method
     * Automatically routes to heightmap or voxel based on mask
     * 
     * @param {number} worldX - World X coordinate (can be fractional)
     * @param {number} worldZ - World Z coordinate (can be fractional)
     * @returns {number} Ground height
     */
    getGroundHeight(worldX, worldZ) {
        const localX = worldX - this.worldMinX;
        const localZ = worldZ - this.worldMinZ;
        
        // Check which collision mode to use
        const cellX = Math.floor(localX);
        const cellZ = Math.floor(localZ);
        
        if (this.usesVoxels(cellX, cellZ)) {
            // Voxel collision: scan down for solid block
            return this.findVoxelGroundHeight(cellX, cellZ);
        } else {
            // Smooth collision: interpolate heightmap
            return this.getInterpolatedHeight(localX, localZ);
        }
    }
    
    /**
     * Find ground height by scanning voxel column
     * @param {number} localX - Local X coordinate
     * @param {number} localZ - Local Z coordinate
     * @returns {number} Height of topmost solid block + 1
     */
    findVoxelGroundHeight(localX, localZ) {
        for (let y = MAX_HEIGHT - 1; y >= 0; y--) {
            const blockType = this.getBlockTypeLocal(localX, y, localZ);
            if (blockType !== null &&
                blockType !== 'water' &&
                blockType !== 'water_full') {
                return y + 1; // Stand ON the block
            }
        }
        return 0;
    }

    /**
     * Get biome at local coordinates
     * @param {number} localX - 0 to CHUNK_SIZE-1
     * @param {number} localZ - 0 to CHUNK_SIZE-1
     * @returns {string|null} Biome name or null if out of bounds or no data
     */
    getBiomeLocal(localX, localZ) {
        if (!this.biomeData) return null;
        if (localX < 0 || localX >= CHUNK_SIZE || localZ < 0 || localZ >= CHUNK_SIZE) {
            return null;
        }
        const index = localZ * CHUNK_SIZE + localX;
        const biomeId = this.biomeData[index];
        return BIOME_NAMES[biomeId] ?? null;
    }

    /**
     * Get biome at world coordinates
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {string|null} Biome name or null if out of bounds or no data
     */
    getBiome(worldX, worldZ) {
        const localX = worldX - this.worldMinX;
        const localZ = worldZ - this.worldMinZ;
        return this.getBiomeLocal(localX, localZ);
    }
}

/**
 * ChunkBlockCache - Central cache for all loaded chunk terrain data
 */
export class ChunkBlockCache {
    constructor() {
        // Map of "chunkX,chunkZ" -> ChunkBlockData
        this.chunks = new Map();

        // Ephemeral heightfield holes created by explosions
        // Map of "chunkX,chunkZ" -> Set of "lx,lz" strings (local coordinates)
        // Cleared when chunk unloads, not persisted
        this.heightfieldHoles = new Map();
    }

    /**
     * Add a heightfield hole at world coordinates
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate
     */
    addHeightfieldHole(worldX, worldZ) {
        const chunkX = Math.floor(worldX / CHUNK_SIZE);
        const chunkZ = Math.floor(worldZ / CHUNK_SIZE);
        const chunkKey = `${chunkX},${chunkZ}`;

        const localX = worldX - chunkX * CHUNK_SIZE;
        const localZ = worldZ - chunkZ * CHUNK_SIZE;
        const holeKey = `${localX},${localZ}`;

        if (!this.heightfieldHoles.has(chunkKey)) {
            this.heightfieldHoles.set(chunkKey, new Set());
        }
        this.heightfieldHoles.get(chunkKey).add(holeKey);
    }

    /**
     * Get heightfield holes for a chunk
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkZ - Chunk Z coordinate
     * @returns {Set|null} Set of "lx,lz" hole coordinates or null
     */
    getHeightfieldHoles(chunkX, chunkZ) {
        return this.heightfieldHoles.get(`${chunkX},${chunkZ}`) || null;
    }

    /**
     * Check if a cell has a heightfield hole
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {boolean} True if cell has a hole
     */
    hasHeightfieldHole(worldX, worldZ) {
        const chunkX = Math.floor(worldX / CHUNK_SIZE);
        const chunkZ = Math.floor(worldZ / CHUNK_SIZE);
        const chunkKey = `${chunkX},${chunkZ}`;

        const holes = this.heightfieldHoles.get(chunkKey);
        if (!holes) return false;

        const localX = worldX - chunkX * CHUNK_SIZE;
        const localZ = worldZ - chunkZ * CHUNK_SIZE;
        return holes.has(`${localX},${localZ}`);
    }

    /**
     * Clear heightfield holes for a chunk (called on unload)
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkZ - Chunk Z coordinate
     */
    clearHeightfieldHoles(chunkX, chunkZ) {
        this.heightfieldHoles.delete(`${chunkX},${chunkZ}`);
    }
    
    /**
     * Store terrain data for a chunk (received from worker)
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkZ - Chunk Z coordinate
     * @param {Object} data - Complete chunk data from worker
     */
    setChunkData(chunkX, chunkZ, data) {
        const key = `${chunkX},${chunkZ}`;
        this.chunks.set(key, new ChunkBlockData(chunkX, chunkZ, data));
    }
    
    /**
     * Remove terrain data for a chunk (when unloaded)
     * Clears both chunk data and any ephemeral heightfield holes
     * @param {number} chunkX - Chunk X coordinate
     * @param {number} chunkZ - Chunk Z coordinate
     */
    removeChunk(chunkX, chunkZ) {
        const key = `${chunkX},${chunkZ}`;
        this.chunks.delete(key);
        // Clear ephemeral heightfield holes when chunk unloads
        this.clearHeightfieldHoles(chunkX, chunkZ);
    }
    
    /**
     * Get chunk data at world coordinates
     * @param {number} x - World X coordinate
     * @param {number} z - World Z coordinate
     * @returns {ChunkBlockData|null} Chunk data or null if not loaded
     */
    getChunkAt(x, z) {
        const chunkX = Math.floor(x / CHUNK_SIZE);
        const chunkZ = Math.floor(z / CHUNK_SIZE);
        return this.chunks.get(`${chunkX},${chunkZ}`) || null;
    }
    
    /**
     * Get block type at world coordinates
     * @param {number} x - World X coordinate
     * @param {number} y - Y coordinate
     * @param {number} z - World Z coordinate
     * @returns {string|null} Block type name, or null for air/unloaded
     */
    getBlockType(x, y, z) {
        const chunkX = Math.floor(x / CHUNK_SIZE);
        const chunkZ = Math.floor(z / CHUNK_SIZE);
        const key = `${chunkX},${chunkZ}`;
        
        const chunkData = this.chunks.get(key);
        if (!chunkData) {
            // Chunk not loaded - treat as air
            return null;
        }
        
        return chunkData.getBlockType(x, y, z);
    }
    
    /**
     * Get ground height at world coordinates
     * Automatically routes to smooth or voxel collision based on mask
     * 
     * @param {number} x - World X coordinate (can be fractional)
     * @param {number} z - World Z coordinate (can be fractional)
     * @returns {number} Ground height, or 0 if chunk not loaded
     */
    getGroundHeight(x, z) {
        const chunk = this.getChunkAt(x, z);
        if (!chunk) {
            return 0;
        }
        return chunk.getGroundHeight(x, z);
    }
    
    /**
     * Check if a position uses voxel collision
     * @param {number} x - World X coordinate
     * @param {number} z - World Z coordinate
     * @returns {boolean} True if voxel collision, false if heightmap
     */
    usesVoxelCollision(x, z) {
        const chunk = this.getChunkAt(x, z);
        if (!chunk) {
            return false;
        }
        const localX = Math.floor(x) - chunk.worldMinX;
        const localZ = Math.floor(z) - chunk.worldMinZ;
        return chunk.usesVoxels(localX, localZ);
    }
    
    /**
     * Check if a chunk's block data is loaded
     */
    hasChunk(chunkX, chunkZ) {
        return this.chunks.has(`${chunkX},${chunkZ}`);
    }

    /**
     * Get biome at world coordinates
     * @param {number} x - World X coordinate
     * @param {number} z - World Z coordinate
     * @returns {string|null} Biome name or null if chunk not loaded
     */
    getBiome(x, z) {
        const chunk = this.getChunkAt(x, z);
        if (!chunk) {
            return null;
        }
        return chunk.getBiome(x, z);
    }

    /**
     * Get number of loaded chunks
     */
    get size() {
        return this.chunks.size;
    }

    /**
     * Clear all cached data
     */
    clear() {
        this.chunks.clear();
    }
}