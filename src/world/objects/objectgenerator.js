import * as THREE from 'three';

/**
 * ObjectGenerator - Mesh factory for static world objects
 *
 * Creates instanced meshes for trees, rocks, cacti, etc. from position data
 * generated by the terrain worker. This class no longer queries terrain -
 * all spawn decisions happen in the worker (objectspawner.js).
 */
export class ObjectGenerator {
    constructor(seed = 54321) {
        this.seed = seed;

        // Object rendering distance (configurable)
        this.objectRenderDistance = 128;

        // Track generated objects by chunk for distance culling
        this.objectsByChunk = new Map();
    }

    /**
     * Simple hash function for deterministic variation (used by createGrass)
     */
    hash(x, z, salt = 0) {
        let h = this.seed + salt + Math.floor(x) * 374761393 + Math.floor(z) * 668265263;
        h = (h ^ (h >> 13)) * 1274126177;
        return ((h ^ (h >> 16)) & 0xffffffff) / 0xffffffff;
    }

    /**
     * Check if there's an object with collision at position
     * Note: Currently all objects have hasCollision: false, so this always returns false.
     * Kept for API compatibility with game.js spawn point finding.
     */
    hasCollision(x, z) {
        // Object collision is not currently used (all OBJECT_TYPES have hasCollision: false)
        // If collision tracking is needed in the future, it should be computed in the worker
        // and stored in a collision map on the main thread
        return false;
    }

    /**
     * Create meshes from worker-computed position data
     * @param {THREE.Scene} scene - Scene to add meshes to
     * @param {number} chunkX - Chunk X index
     * @param {number} chunkZ - Chunk Z index
     * @param {Object} staticObjects - Map of object type to Float32Array positions
     */
    createMeshesFromWorkerData(scene, chunkX, chunkZ, staticObjects) {
        const chunkKey = `${chunkX},${chunkZ}`;

        // Convert Float32Arrays to position arrays
        const toPositions = (data) => {
            if (!data || data.length === 0) return [];
            const positions = [];
            for (let i = 0; i < data.length; i += 4) {
                positions.push({
                    x: data[i],
                    y: data[i + 1],
                    z: data[i + 2],
                    variation: data[i + 3]
                });
            }
            return positions;
        };

        // Create instanced meshes and track them by chunk
        const meshes = [];

        if (staticObjects.tree?.length > 0) {
            meshes.push(...this.createTrees(scene, toPositions(staticObjects.tree), false));
        }
        if (staticObjects.snowTree?.length > 0) {
            meshes.push(...this.createTrees(scene, toPositions(staticObjects.snowTree), true));
        }
        if (staticObjects.jungleTree?.length > 0) {
            meshes.push(...this.createJungleTrees(scene, toPositions(staticObjects.jungleTree)));
        }
        if (staticObjects.rock?.length > 0) {
            meshes.push(...this.createRocks(scene, toPositions(staticObjects.rock), false));
        }
        if (staticObjects.boulder?.length > 0) {
            meshes.push(...this.createRocks(scene, toPositions(staticObjects.boulder), true));
        }
        if (staticObjects.grass?.length > 0) {
            meshes.push(...this.createGrass(scene, toPositions(staticObjects.grass)));
        }
        if (staticObjects.cactus?.length > 0) {
            meshes.push(...this.createCacti(scene, toPositions(staticObjects.cactus)));
        }

        // Store meshes for this chunk (for distance culling)
        this.objectsByChunk.set(chunkKey, meshes);

        return meshes;
    }
    
    /**
     * Update object visibility based on distance from player
     */
    updateObjectVisibility(playerPosition) {
        const distanceSquared = this.objectRenderDistance * this.objectRenderDistance;
        
        this.objectsByChunk.forEach((meshes, chunkKey) => {
            const [chunkX, chunkZ] = chunkKey.split(',').map(Number);
            const CHUNK_SIZE = 16;
            
            const chunkCenterX = (chunkX * CHUNK_SIZE) + (CHUNK_SIZE / 2);
            const chunkCenterZ = (chunkZ * CHUNK_SIZE) + (CHUNK_SIZE / 2);
            
            const dx = chunkCenterX - playerPosition.x;
            const dz = chunkCenterZ - playerPosition.z;
            const distSq = dx * dx + dz * dz;
            
            const shouldBeVisible = distSq <= distanceSquared;
            
            meshes.forEach(mesh => {
                if (mesh && mesh.visible !== shouldBeVisible) {
                    mesh.visible = shouldBeVisible;
                }
            });
        });
    }
    
    /**
     * Remove objects within a radius of a world position (e.g., explosion)
     * Works by setting instance scale to 0 for affected objects
     * @param {THREE.Vector3} position - Center of explosion
     * @param {number} radius - Radius to clear
     */
    removeObjectsInRadius(position, radius) {
        const radiusSq = radius * radius;
        const matrix = new THREE.Matrix4();
        const pos = new THREE.Vector3();
        const rot = new THREE.Quaternion();
        const scale = new THREE.Vector3();
        const zeroScale = new THREE.Vector3(0, 0, 0);

        // Check all chunks that might be affected
        this.objectsByChunk.forEach((meshes) => {
            meshes.forEach(mesh => {
                if (!mesh || !mesh.isInstancedMesh) return;

                let updated = false;
                for (let i = 0; i < mesh.count; i++) {
                    mesh.getMatrixAt(i, matrix);
                    matrix.decompose(pos, rot, scale);

                    // Skip already removed instances (scale 0)
                    if (scale.x === 0) continue;

                    const dx = pos.x - position.x;
                    const dy = pos.y - position.y;
                    const dz = pos.z - position.z;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq <= radiusSq) {
                        // Set scale to 0 to "remove" this instance
                        matrix.compose(pos, rot, zeroScale);
                        mesh.setMatrixAt(i, matrix);
                        updated = true;
                    }
                }

                if (updated) {
                    mesh.instanceMatrix.needsUpdate = true;
                }
            });
        });
    }

    /**
     * Remove objects for an unloaded chunk
     */
    unloadChunk(chunkX, chunkZ) {
        const chunkKey = `${chunkX},${chunkZ}`;
        const meshes = this.objectsByChunk.get(chunkKey);
        
        if (meshes) {
            meshes.forEach(mesh => {
                if (mesh && mesh.parent) {
                    mesh.parent.remove(mesh);
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) {
                        if (Array.isArray(mesh.material)) {
                            mesh.material.forEach(m => m.dispose());
                        } else {
                            mesh.material.dispose();
                        }
                    }
                }
            });
            
            this.objectsByChunk.delete(chunkKey);
        }
    }

    createTrees(scene, positions, isSnowy) {
        if (positions.length === 0) return [];

        const trunkColor = 0x8B4513;
        const foliageColor = isSnowy ? 0x228B22 : 0x2E8B2E;

        // Trunk geometry
        const trunkGeo = new THREE.CylinderGeometry(0.15, 0.2, 1.2, 6);
        const trunkMat = new THREE.MeshLambertMaterial({ color: trunkColor });
        const trunkMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, positions.length);
        trunkMesh.castShadow = true;
        trunkMesh.receiveShadow = true;

        // Foliage - cone for snowy (fir trees), sphere for regular
        let foliageGeo;
        if (isSnowy) {
            foliageGeo = new THREE.ConeGeometry(0.7, 1.8, 6);
        } else {
            foliageGeo = new THREE.SphereGeometry(0.8, 6, 4);
        }
        const foliageMat = new THREE.MeshLambertMaterial({ color: foliageColor });
        const foliageMesh = new THREE.InstancedMesh(foliageGeo, foliageMat, positions.length);
        foliageMesh.castShadow = true;
        foliageMesh.receiveShadow = true;

        const matrix = new THREE.Matrix4();
        const quaternion = new THREE.Quaternion();
        const scale = new THREE.Vector3();

        positions.forEach((pos, i) => {
            const sizeVar = 0.8 + pos.variation * 0.4;
            
            scale.set(sizeVar, sizeVar, sizeVar);
            const trunkY = pos.y + 0.6 * sizeVar;
            matrix.compose(
                new THREE.Vector3(pos.x, trunkY, pos.z),
                quaternion,
                scale
            );
            trunkMesh.setMatrixAt(i, matrix);

            const trunkTop = trunkY + 0.6 * sizeVar;
            const foliageY = isSnowy ? trunkTop + 0.9 * sizeVar : trunkTop + 0.4 * sizeVar;
            matrix.compose(
                new THREE.Vector3(pos.x, foliageY, pos.z),
                quaternion,
                scale
            );
            foliageMesh.setMatrixAt(i, matrix);
        });

        trunkMesh.instanceMatrix.needsUpdate = true;
        foliageMesh.instanceMatrix.needsUpdate = true;

        scene.add(trunkMesh);
        scene.add(foliageMesh);

        const meshes = [trunkMesh, foliageMesh];

        // Snow caps for fir trees
        if (isSnowy && positions.length > 0) {
            const snowGeometry = new THREE.ConeGeometry(0.6, 1.4, 6);
            const snowMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
            const snowMesh = new THREE.InstancedMesh(snowGeometry, snowMaterial, positions.length);
            snowMesh.castShadow = true;
            snowMesh.receiveShadow = true;

            positions.forEach((pos, i) => {
                const sizeVar = 0.8 + pos.variation * 0.4;
                const trunkY = pos.y + 0.6 * sizeVar;
                const trunkTop = trunkY + 0.6 * sizeVar;
                const foliageY = trunkTop + 0.9 * sizeVar;
                const snowY = foliageY + 0.2 * sizeVar;
                matrix.compose(
                    new THREE.Vector3(pos.x, snowY, pos.z),
                    quaternion,
                    new THREE.Vector3(sizeVar, sizeVar, sizeVar)
                );
                snowMesh.setMatrixAt(i, matrix);
            });

            snowMesh.instanceMatrix.needsUpdate = true;
            scene.add(snowMesh);
            meshes.push(snowMesh);
        }
        
        return meshes;
    }

    createJungleTrees(scene, positions) {
        if (positions.length === 0) return [];

        const trunkColor = 0x5D4037;
        const foliageColor = 0x1B5E20;

        // Tall trunk
        const trunkGeo = new THREE.CylinderGeometry(0.25, 0.35, 5, 8);
        const trunkMat = new THREE.MeshLambertMaterial({ color: trunkColor });
        const trunkMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, positions.length);
        trunkMesh.castShadow = true;

        // Large canopy
        const foliageGeo = new THREE.SphereGeometry(2.0, 10, 8);
        const foliageMat = new THREE.MeshLambertMaterial({ color: foliageColor });
        const foliageMesh = new THREE.InstancedMesh(foliageGeo, foliageMat, positions.length);
        foliageMesh.castShadow = true;
        foliageMesh.receiveShadow = true;

        const matrix = new THREE.Matrix4();
        const quaternion = new THREE.Quaternion();

        positions.forEach((pos, i) => {
            const sizeVar = 0.8 + pos.variation * 0.4;
            
            // Trunk - base at ground level
            const trunkY = pos.y + 2.5 * sizeVar;
            matrix.compose(
                new THREE.Vector3(pos.x, trunkY, pos.z),
                quaternion,
                new THREE.Vector3(sizeVar, sizeVar, sizeVar)
            );
            trunkMesh.setMatrixAt(i, matrix);

            // Canopy
            const foliageY = trunkY + 3.0 * sizeVar;
            matrix.compose(
                new THREE.Vector3(pos.x, foliageY, pos.z),
                quaternion,
                new THREE.Vector3(sizeVar, sizeVar * 0.7, sizeVar)
            );
            foliageMesh.setMatrixAt(i, matrix);
        });

        trunkMesh.instanceMatrix.needsUpdate = true;
        foliageMesh.instanceMatrix.needsUpdate = true;

        scene.add(trunkMesh);
        scene.add(foliageMesh);

        return [trunkMesh, foliageMesh];
    }

    createRocks(scene, positions, isLarge) {
        if (positions.length === 0) return [];

        const rockColor = isLarge ? 0x696969 : 0x808080;
        const geometry = isLarge 
            ? new THREE.DodecahedronGeometry(0.6, 0)
            : new THREE.DodecahedronGeometry(0.35, 0);
        
        const material = new THREE.MeshLambertMaterial({ color: rockColor });
        const mesh = new THREE.InstancedMesh(geometry, material, positions.length);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        const matrix = new THREE.Matrix4();
        const quaternion = new THREE.Quaternion();
        const euler = new THREE.Euler();

        positions.forEach((pos, i) => {
            const sizeVar = 0.7 + pos.variation * 0.6;
            
            euler.set(
                pos.variation * Math.PI,
                pos.variation * Math.PI * 2,
                pos.variation * Math.PI * 0.5
            );
            quaternion.setFromEuler(euler);

            // Rock sits on ground - slight embed
            const yOffset = isLarge ? 0.3 * sizeVar : 0.15 * sizeVar;
            matrix.compose(
                new THREE.Vector3(pos.x, pos.y + yOffset, pos.z),
                quaternion,
                new THREE.Vector3(sizeVar, sizeVar * 0.7, sizeVar)
            );
            mesh.setMatrixAt(i, matrix);
        });

        mesh.instanceMatrix.needsUpdate = true;
        scene.add(mesh);
        
        return [mesh];
    }

    createGrass(scene, positions) {
        if (positions.length === 0) return [];

        const grassGeometry = new THREE.ConeGeometry(0.1, 0.4, 4);
        const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x3CB371 });
        const mesh = new THREE.InstancedMesh(grassGeometry, grassMaterial, positions.length * 3);

        const matrix = new THREE.Matrix4();
        const quaternion = new THREE.Quaternion();

        let index = 0;
        positions.forEach((pos) => {
            for (let i = 0; i < 3; i++) {
                const offsetX = (this.hash(pos.x, pos.z, i * 100) - 0.5) * 0.6;
                const offsetZ = (this.hash(pos.x, pos.z, i * 100 + 50) - 0.5) * 0.6;
                const sizeVar = 0.6 + this.hash(pos.x, pos.z, i * 100 + 25) * 0.8;
                const rotY = this.hash(pos.x, pos.z, i * 100 + 75) * Math.PI * 2;

                quaternion.setFromEuler(new THREE.Euler(0, rotY, 0));
                matrix.compose(
                    new THREE.Vector3(pos.x + offsetX, pos.y + 0.15 * sizeVar, pos.z + offsetZ),
                    quaternion,
                    new THREE.Vector3(sizeVar, sizeVar, sizeVar)
                );
                mesh.setMatrixAt(index++, matrix);
            }
        });

        mesh.instanceMatrix.needsUpdate = true;
        scene.add(mesh);
        
        return [mesh];
    }

    createCacti(scene, positions) {
        if (positions.length === 0) return [];

        const cactusColor = 0x2E8B2E;

        const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.25, 1.5, 6);
        const material = new THREE.MeshLambertMaterial({ color: cactusColor });
        const bodyMesh = new THREE.InstancedMesh(bodyGeometry, material, positions.length);
        bodyMesh.castShadow = true;

        const armGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.5, 5);
        const armsWithArms = positions.filter(p => p.variation > 0.4);
        const armMesh = new THREE.InstancedMesh(armGeometry, material, armsWithArms.length * 2);
        armMesh.castShadow = true;

        const matrix = new THREE.Matrix4();
        const quaternion = new THREE.Quaternion();

        positions.forEach((pos, i) => {
            const sizeVar = 0.8 + pos.variation * 0.4;
            
            // Body - base at ground level
            matrix.compose(
                new THREE.Vector3(pos.x, pos.y + 0.75 * sizeVar, pos.z),
                quaternion,
                new THREE.Vector3(sizeVar, sizeVar, sizeVar)
            );
            bodyMesh.setMatrixAt(i, matrix);
        });

        // Arms for some cacti
        let armIndex = 0;
        armsWithArms.forEach((pos) => {
            const sizeVar = 0.8 + pos.variation * 0.4;
            const armY = pos.y + 0.8 * sizeVar;
            
            // Left arm
            const leftQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, Math.PI / 3));
            matrix.compose(
                new THREE.Vector3(pos.x - 0.3 * sizeVar, armY, pos.z),
                leftQ,
                new THREE.Vector3(sizeVar, sizeVar, sizeVar)
            );
            armMesh.setMatrixAt(armIndex++, matrix);

            // Right arm
            const rightQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, -Math.PI / 3));
            matrix.compose(
                new THREE.Vector3(pos.x + 0.3 * sizeVar, armY, pos.z),
                rightQ,
                new THREE.Vector3(sizeVar, sizeVar, sizeVar)
            );
            armMesh.setMatrixAt(armIndex++, matrix);
        });

        bodyMesh.instanceMatrix.needsUpdate = true;
        armMesh.instanceMatrix.needsUpdate = true;

        scene.add(bodyMesh);
        scene.add(armMesh);

        return [bodyMesh, armMesh];
    }
}